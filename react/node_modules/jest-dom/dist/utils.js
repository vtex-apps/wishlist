'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matches = exports.getMessage = exports.deprecate = exports.checkValidCSS = exports.checkHtmlElement = exports.checkDocumentKey = undefined;

var _redent = require('redent');

var _redent2 = _interopRequireDefault(_redent);

var _jestMatcherUtils = require('jest-matcher-utils');

var _css = require('css');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HtmlElementTypeError = function (_Error) {
  _inherits(HtmlElementTypeError, _Error);

  function HtmlElementTypeError(received, matcherFn, context) {
    _classCallCheck(this, HtmlElementTypeError);

    /* istanbul ignore next */
    var _this = _possibleConstructorReturn(this, _Error.call(this));

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_this, matcherFn);
    }
    _this.message = [(0, _jestMatcherUtils.matcherHint)(`${context.isNot ? '.not' : ''}.${matcherFn.name}`, 'received', ''), '', `${(0, _jestMatcherUtils.RECEIVED_COLOR)('received')} value must be an HTMLElement or an SVGElement.`, (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)].join('\n');
    return _this;
  }

  return HtmlElementTypeError;
}(Error);

function checkHtmlElement(htmlElement) {
  if (!(htmlElement instanceof HTMLElement) && !(htmlElement instanceof SVGElement)) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    throw new (Function.prototype.bind.apply(HtmlElementTypeError, [null].concat([htmlElement], args)))();
  }
}

var InvalidCSSError = function (_Error2) {
  _inherits(InvalidCSSError, _Error2);

  function InvalidCSSError(received, matcherFn) {
    _classCallCheck(this, InvalidCSSError);

    /* istanbul ignore next */
    var _this2 = _possibleConstructorReturn(this, _Error2.call(this));

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_this2, matcherFn);
    }
    _this2.message = [received.message, '', (0, _jestMatcherUtils.RECEIVED_COLOR)(`Failing css:`), (0, _jestMatcherUtils.RECEIVED_COLOR)(`${received.css}`)].join('\n');
    return _this2;
  }

  return InvalidCSSError;
}(Error);

function checkValidCSS(css) {
  var ast = (0, _css.parse)(`selector { ${css} }`, { silent: true }).stylesheet;

  if (ast.parsingErrors && ast.parsingErrors.length > 0) {
    var _ast$parsingErrors$ = ast.parsingErrors[0],
        reason = _ast$parsingErrors$.reason,
        line = _ast$parsingErrors$.line;

    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    throw new (Function.prototype.bind.apply(InvalidCSSError, [null].concat([{
      css,
      message: `Syntax error parsing expected css: ${reason} on line: ${line}`
    }], args)))();
  }
}

var InvalidDocumentError = function (_Error3) {
  _inherits(InvalidDocumentError, _Error3);

  function InvalidDocumentError(message, matcherFn) {
    _classCallCheck(this, InvalidDocumentError);

    /* istanbul ignore next */
    var _this3 = _possibleConstructorReturn(this, _Error3.call(this));

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_this3, matcherFn);
    }

    _this3.message = message;
    return _this3;
  }

  return InvalidDocumentError;
}(Error);

function checkDocumentKey(document, key, matcherFn) {
  if (typeof document === 'undefined') {
    throw new InvalidDocumentError(`document is undefined on global but is required to use ${matcherFn.name}.`, matcherFn);
  }

  if (typeof document[key] === 'undefined') {
    throw new InvalidDocumentError(`${key} is undefined on document but is required to use ${matcherFn.name}.`, matcherFn);
  }
}

function display(value) {
  return typeof value === 'string' ? value : (0, _jestMatcherUtils.stringify)(value);
}

function getMessage(matcher, expectedLabel, expectedValue, receivedLabel, receivedValue) {
  return [`${matcher}\n`, `${expectedLabel}:\n${(0, _jestMatcherUtils.EXPECTED_COLOR)((0, _redent2.default)(display(expectedValue), 2))}`, `${receivedLabel}:\n${(0, _jestMatcherUtils.RECEIVED_COLOR)((0, _redent2.default)(display(receivedValue), 2))}`].join('\n');
}

function matches(textToMatch, node, matcher) {
  if (matcher instanceof RegExp) {
    return matcher.test(textToMatch);
  } else {
    return textToMatch.toLowerCase().includes(String(matcher).toLowerCase());
  }
}

function deprecate(name, replacementText) {
  // Notify user that they are using deprecated functionality.
  // eslint-disable-next-line no-console
  console.warn(`Warning: ${name} has been deprecated and will be removed in future updates.`, replacementText);
}

exports.checkDocumentKey = checkDocumentKey;
exports.checkHtmlElement = checkHtmlElement;
exports.checkValidCSS = checkValidCSS;
exports.deprecate = deprecate;
exports.getMessage = getMessage;
exports.matches = matches;