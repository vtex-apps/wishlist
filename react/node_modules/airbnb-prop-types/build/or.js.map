{"version":3,"sources":["../src/or.js"],"names":["or","oneOfTypeValidator","validators","validator","oneOfType","props","propName","componentName","rest","propValue","errors","map","v","filter","Boolean","length","TypeError","isRequired","oneOfTypeRequired","name","Array","isArray","RangeError"],"mappings":";;;qBAqCwBA,E;;AArCxB;;AACA;;;;;;;;AAEA,SAASC,kBAAT,CAA4BC,UAA5B,EAAwC;AACtC,MAAMC;AAAY,aAASC,SAAT,CAAmBC,KAAnB,EAA0BC,QAA1B,EAAoCC,aAApC,EAA4D;AAAA,wCAANC,IAAM;AAANA,YAAM;AAAA;;AAAA,UACxDC,SADwD,GAC1CJ,KAD0C,CACnEC,QADmE;;AAE5E,UAAI,OAAOG,SAAP,KAAqB,WAAzB,EAAsC;AACpC,eAAO,IAAP;AACD;;AAED,UAAMC,SAASR,WACZS,GADY,CACR;AAAA,eAAKC,oBAAEP,KAAF,EAASC,QAAT,EAAmBC,aAAnB,SAAqCC,IAArC,EAAL;AAAA,OADQ,EAEZK,MAFY,CAELC,OAFK,CAAf;;AAIA,UAAIJ,OAAOK,MAAP,GAAgBb,WAAWa,MAA/B,EAAuC;AACrC,eAAO,IAAP;AACD;AACD,aAAO,IAAIC,SAAJ,QAAiBT,aAAjB,4CAA6DD,QAA7D,QAAP;AACD;;AAdK,WAAqBF,SAArB;AAAA,KAAN;AAeAD,YAAUc,UAAV;AAAuB,aAASC,iBAAT,CAA2Bb,KAA3B,EAAkCC,QAAlC,EAA4CC,aAA5C,EAAoE;AAAA,yCAANC,IAAM;AAANA,YAAM;AAAA;;AAAA,UACrEC,SADqE,GACvDJ,KADuD,CAChFC,QADgF;;AAEzF,UAAI,OAAOG,SAAP,KAAqB,WAAzB,EAAsC;AACpC,eAAO,IAAIO,SAAJ,QAAiBT,aAAjB,6CAA8DD,QAA9D,QAAP;AACD;;AAED,UAAMI,SAASR,WACZS,GADY,CACR;AAAA,eAAKC,oBAAEP,KAAF,EAASC,QAAT,EAAmBC,aAAnB,SAAqCC,IAArC,EAAL;AAAA,OADQ,EAEZK,MAFY,CAELC,OAFK,CAAf;;AAIA,UAAIJ,OAAOK,MAAP,KAAkBb,WAAWa,MAAjC,EAAyC;AACvC,eAAO,IAAIC,SAAJ,QAAiBT,aAAjB,gCAAiDG,MAAjD,sCAAgFJ,QAAhF,QAAP;AACD;AACD,aAAO,IAAP;AACD;;AAdD,WAAgCY,iBAAhC;AAAA;AAeA,SAAO,gCAAcf,SAAd,EAAyB,WAAzB,EAAsCD,UAAtC,CAAP;AACD;;AAEc,SAASF,EAAT,CAAYE,UAAZ,EAAqC;AAAA,MAAbiB,IAAa,uEAAN,IAAM;;AAClD,MAAI,CAACC,MAAMC,OAAN,CAAcnB,UAAd,CAAL,EAAgC;AAC9B,UAAM,IAAIc,SAAJ,CAAc,uCAAd,CAAN;AACD;AACD,MAAId,WAAWa,MAAX,IAAqB,CAAzB,EAA4B;AAC1B,UAAM,IAAIO,UAAJ,CAAe,uCAAf,CAAN;AACD;;AAED,MAAMnB,YAAYF,oBAChB,wBAAQA,mBAAmBC,UAAnB,CAAR,CADgB,4BAEbA,UAFa,GAAlB;;AAKA,SAAO,gCAAcC,SAAd,EAAyBgB,IAAzB,EAA+BjB,UAA/B,CAAP;AACD","file":"or.js","sourcesContent":["import { arrayOf } from 'prop-types';\nimport wrapValidator from './helpers/wrapValidator';\n\nfunction oneOfTypeValidator(validators) {\n  const validator = function oneOfType(props, propName, componentName, ...rest) {\n    const { [propName]: propValue } = props;\n    if (typeof propValue === 'undefined') {\n      return null;\n    }\n\n    const errors = validators\n      .map(v => v(props, propName, componentName, ...rest))\n      .filter(Boolean);\n\n    if (errors.length < validators.length) {\n      return null;\n    }\n    return new TypeError(`${componentName}: invalid value supplied to ${propName}.`);\n  };\n  validator.isRequired = function oneOfTypeRequired(props, propName, componentName, ...rest) {\n    const { [propName]: propValue } = props;\n    if (typeof propValue === 'undefined') {\n      return new TypeError(`${componentName}: missing value for required ${propName}.`);\n    }\n\n    const errors = validators\n      .map(v => v(props, propName, componentName, ...rest))\n      .filter(Boolean);\n\n    if (errors.length === validators.length) {\n      return new TypeError(`${componentName}: invalid value ${errors} supplied to required ${propName}.`);\n    }\n    return null;\n  };\n  return wrapValidator(validator, 'oneOfType', validators);\n}\n\nexport default function or(validators, name = 'or') {\n  if (!Array.isArray(validators)) {\n    throw new TypeError('or: 2 or more validators are required');\n  }\n  if (validators.length <= 1) {\n    throw new RangeError('or: 2 or more validators are required');\n  }\n\n  const validator = oneOfTypeValidator([\n    arrayOf(oneOfTypeValidator(validators)),\n    ...validators,\n  ]);\n\n  return wrapValidator(validator, name, validators);\n}\n"]}